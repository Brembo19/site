<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FiveM Threat Scanner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/disable-devtool@0.3.7/disable-devtool.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.24.7/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com/3.4.3"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #f59e0b;
            --danger: #ef4444;
            --success: #10b981;
            --warning: #f59e0b;
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-accent: #16213e;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-accent: #64748b;
            --border: #334155;
            --glow: rgba(99, 102, 241, 0.5);
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--bg-secondary);
        }

        *::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        *::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        *::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
            border: 2px solid var(--bg-secondary);
        }

        *::-webkit-scrollbar-thumb:hover {
            background: var(--primary-light);
        }

        body {
            background: radial-gradient(ellipse at top, var(--bg-accent) 0%, var(--bg-primary) 100%);
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            color: var(--text-primary);
        }

        .glass-effect {
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .glow-border {
            position: relative;
            overflow: hidden;
        }

        .glow-border::before {
            content: '';
            position: absolute;
            inset: 0;
            padding: 1px;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--primary));
            border-radius: inherit;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            -webkit-mask-composite: xor;
        }

        .scan-button {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .scan-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .scan-button:hover::before {
            left: 100%;
        }

        .scan-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.6);
        }

        .scan-button:active {
            transform: translateY(0);
        }

        .progress-bar {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            box-shadow: 0 0 20px var(--glow);
            transition: width 0.3s ease;
        }

        .threat-card {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.9) 0%, rgba(22, 33, 62, 0.9) 100%);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .threat-card:hover {
            border-color: var(--primary);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.2);
            transform: translateY(-2px);
        }

        .backdoor-threat {
            border-left: 4px solid var(--danger);
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(26, 26, 46, 0.9) 100%);
        }

        .regular-threat {
            border-left: 4px solid var(--warning);
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(26, 26, 46, 0.9) 100%);
        }

        .file-input {
            background: var(--bg-secondary);
            border: 2px dashed var(--border);
            transition: all 0.3s ease;
            position: relative;
        }

        .file-input:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .file-input input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .pulse-animation {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: .8;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .code-block {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .stats-card {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-accent) 100%);
            border: 1px solid var(--border);
        }

        .floating-orb {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
            opacity: 0.1;
            animation: float 6s ease-in-out infinite;
            pointer-events: none;
        }

        .floating-orb:nth-child(1) {
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .floating-orb:nth-child(2) {
            top: 60%;
            right: 10%;
            animation-delay: 2s;
        }

        .floating-orb:nth-child(3) {
            bottom: 10%;
            left: 50%;
            animation-delay: 4s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            50% {
                transform: translateY(-20px) scale(1.1);
            }
        }

        .gradient-text {
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body>
    <div class="floating-orb"></div>
    <div class="floating-orb"></div>
    <div class="floating-orb"></div>
    
    <div id="root" class="min-h-screen py-8 px-4"></div>
    
    <script type="text/babel" data-presets="react">
        const THREAT_PATTERNS = [
            { pattern: /backdoor/i, desc: "Backdoor Reference" },
            { pattern: /PerformHttpRequest/i, desc: "Backdoor: FiveM HTTP Request" },
            { pattern: /http\.request/i, desc: "Backdoor: Lua HTTP Request" },
            { pattern: /loadstring/i, desc: "Backdoor: Dynamic Lua Code" },
            { pattern: /os\.execute/i, desc: "System Command Execution" },
            { pattern: /exec/i, desc: "Code Execution" },
            { pattern: /socket/i, desc: "Network Socket" },
            { pattern: /connect/i, desc: "Connection Attempt" },
            { pattern: /eval/i, desc: "JS Eval" },
            { pattern: /Function\.constructor/i, desc: "Dynamic JS Code" },
            { pattern: /XMLHttpRequest/i, desc: "JS HTTP Request" },
            { pattern: /fetch/i, desc: "JS Fetch API" },
            { pattern: /crypto/i, desc: "Crypto Library" },
            { pattern: /wallet/i, desc: "Crypto Wallet" },
            { pattern: /miner/i, desc: "Crypto Miner" },
            { pattern: /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/, desc: "Bitcoin Address" },
            { pattern: /0x[a-fA-F0-9]{40}/, desc: "Ethereum Address" },
            { pattern: /mining/i, desc: "Mining Keyword" },
            { pattern: /hashrate/i, desc: "Mining Metric" },
            { pattern: /blockchain/i, desc: "Blockchain Term" },
            { pattern: /WebAssembly/i, desc: "WASM Mining" },
            { pattern: /crypto\.subtle/i, desc: "Web Crypto API" },
            { pattern: /\\x[0-9a-fA-F]{2}(\\x[0-9a-fA-F]{2}){3,}/, desc: "Obfuscated Hex Payload" },
            { pattern: /_G\s*\[[^\]]+\]\s*\(/i, desc: "Backdoor: Dynamic Global Function Call" },
            { pattern: /=\s*{[^}]*\\x[0-9a-fA-F]{2}/, desc: "Obfuscated Array with Hex Values" },
            { pattern: /\[\s*_G\s*\[\s*["']?[a-zA-Z0-9_]{4,}["']?\s*\]\s*\]/i, desc: "Backdoor: Nested _G Lookup" },
            { pattern: /webhook/i, desc: "Webhook Reference" },
            { pattern: /Buffer\.from\s*\(\s*['"][A-Za-z0-9+/=]+['"]\s*,\s*['"]base64['"]\s*\)/i, desc: "Obfuscated JS Buffer Payload" },
            { pattern: /load\s*\(\s*[^)]+\)/i, desc: "Backdoor: Lua Load Function" },
            { pattern: /RunCode\s*\(/i, desc: "Backdoor: FiveM RunCode Execution" },
            { pattern: /http\.Get\s*\(/i, desc: "Backdoor: FiveM HTTP Get Request" },
            { pattern: /TriggerServerEvent\s*\(\s*['"][^'"]+['"]\s*,/i, desc: "Backdoor: Suspicious Server Event Trigger" },
            { pattern: /ExecuteCommand\s*\(\s*['"][^'"]+['"]\s*\)/i, desc: "Backdoor: Command Execution" },
            { pattern: /AddEventHandler\s*\(\s*['"][^'"]+['"]\s*,/i, desc: "Backdoor: Suspicious Event Handler" },
            { pattern: /Citizen\.CreateThread\s*\(/i, desc: "Backdoor: Citizen Thread Creation" },
            { pattern: /string\.char\s*\(\s*(0x[0-9a-fA-F]+|[0-9]+)\s*[,)]/i, desc: "Backdoor: Obfuscated String via string.char" },
            { pattern: /[\w]+\s*\.\s*concat\s*\(\s*[\w]+\s*\)/i, desc: "Backdoor: String Concatenation Obfuscation" }
        ];

        // Web Worker script
        const workerScript = `
            const THREAT_PATTERNS = ${JSON.stringify(THREAT_PATTERNS)};

            const xorDecode = (text, key = "secret") => {
                try {
                    key = key.slice(0, Math.min(text.length, key.length)) || "secret";
                    let result = '';
                    for (let i = 0; i < text.length; i++) {
                        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return result.split('').every(c => (c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126) || ['\\n', '\\r', '\\t'].includes(c)) ? result : null;
                } catch (e) {
                    return { error: 'XOR Decode Error: ' + e.message };
                }
            };

            const base64Decode = (text) => {
                try {
                    if (text.length % 4 !== 0) text += '='.repeat(4 - text.length % 4);
                    const decoded = atob(text);
                    return decoded.split('').every(c => (c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126) || ['\\n', '\\r', '\\t'].includes(c)) ? decoded : null;
                } catch (e) {
                    return { error: 'Base64 Decode Error: ' + e.message };
                }
            };

            const scanFile = (fileName, content) => {
                const findings = [];
                const seen = new Set();
                const lines = content.split('\\n');
                const lang = fileName.match(/\\.js$/i) ? 'js' : fileName.match(/\\.lua$/i) ? 'lua' : 'text';
                const MAX_MATCHES = 100;

                for (const { pattern, desc } of THREAT_PATTERNS) {
                    try {
                        const regex = new RegExp(pattern.source, pattern.flags);
                        let match;
                        let matchCount = 0;
                        while ((match = regex.exec(content)) && matchCount < MAX_MATCHES) {
                            const lineNum = content.slice(0, match.index).split('\\n').length;
                            const key = fileName + ':' + lineNum + ':' + desc;
                            if (!seen.has(key)) {
                                seen.add(key);
                                const contextLines = desc.includes("Backdoor") ? 5 : 3;
                                const startLine = Math.max(0, lineNum - contextLines);
                                const endLine = Math.min(lines.length, lineNum + contextLines);
                                let snippet = lines.slice(startLine, endLine).join('\\n').slice(0, 900);
                                if (snippet.length >= 900) snippet += '...';
                                findings.push({
                                    file: fileName,
                                    line: lineNum,
                                    desc,
                                    snippet,
                                    lang,
                                    isBackdoor: desc.includes("Backdoor")
                                });
                            }
                            matchCount++;
                        }
                    } catch (e) {
                        const key = fileName + ':0:Regex Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "Regex Error",
                                snippet: ('Regex Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                const base64Matches = content.match(/[A-Za-z0-9+/=]{20,}/g) || [];
                for (const match of base64Matches) {
                    try {
                        const decoded = base64Decode(match);
                        if (decoded && !decoded.error) {
                            let matchCount = 0;
                            for (const { pattern, desc } of THREAT_PATTERNS) {
                                if (matchCount >= MAX_MATCHES) break;
                                if (pattern.test(decoded)) {
                                    const key = fileName + ':0:' + desc + ' (Base64)';
                                    if (!seen.has(key)) {
                                        seen.add(key);
                                        const snippet = decoded.slice(0, 900) + (decoded.length > 900 ? '...' : '');
                                        findings.push({
                                            file: fileName,
                                            line: 0,
                                            desc: desc + ' (Base64)',
                                            snippet,
                                            lang,
                                            isBackdoor: desc.includes("Backdoor")
                                        });
                                    }
                                    matchCount++;
                                }
                            }
                        } else if (decoded && decoded.error) {
                            const key = fileName + ':0:Base64 Decode Error';
                            if (!seen.has(key)) {
                                seen.add(key);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Base64 Decode Error",
                                    snippet: decoded.error.slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                            }
                        }
                    } catch (e) {
                        const key = fileName + ':0:Base64 Decode Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "Base64 Decode Error",
                                snippet: ('Base64 Decode Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                const keys = ["secret", "key", "xor", "password", "fivem", "lua", "backdoor", "crypto", "mine"];
                for (const xorKey of keys) {
                    try {
                        const decoded = xorDecode(content, xorKey);
                        if (decoded && !decoded.error) {
                            let matchCount = 0;
                            for (const { pattern, desc } of THREAT_PATTERNS) {
                                if (matchCount >= MAX_MATCHES) break;
                                if (pattern.test(decoded)) {
                                    const uniqueKey = fileName + ':0:' + desc + ' (XOR: ' + xorKey + ')';
                                    if (!seen.has(uniqueKey)) {
                                        seen.add(uniqueKey);
                                        const snippet = decoded.slice(0, 900) + (decoded.length > 900 ? '...' : '');
                                        findings.push({
                                            file: fileName,
                                            line: 0,
                                            desc: desc + ' (XOR: ' + xorKey + ')',
                                            snippet,
                                            lang,
                                            isBackdoor: desc.includes("Backdoor")
                                        });
                                    }
                                    matchCount++;
                                }
                            }
                        } else if (decoded && decoded.error) {
                            const key = fileName + ':0:XOR Decode Error';
                            if (!seen.has(key)) {
                                seen.add(key);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "XOR Decode Error",
                                    snippet: decoded.error.slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                            }
                        }
                    } catch (e) {
                        const key = fileName + ':0:XOR Decode Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "XOR Decode Error",
                                snippet: ('XOR Decode Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                return findings;
            };

            self.onmessage = async (e) => {
                try {
                    const { fileName, content } = e.data;
                    if (content.length > 10 * 1024 * 1024) {
                        self.postMessage({
                            fileName,
                            findings: [{
                                file: fileName,
                                line: 0,
                                desc: "File Too Large",
                                snippet: "File exceeds 10MB limit",
                                lang: 'text',
                                isBackdoor: false
                            }]
                        });
                        return;
                    }
                    const findings = scanFile(fileName, content);
                    self.postMessage({ fileName, findings });
                } catch (e) {
                    self.postMessage({
                        fileName: e.data?.fileName || 'Unknown',
                        findings: [{
                            file: e.data?.fileName || 'Unknown',
                            line: 0,
                            desc: "Worker Error",
                            snippet: ('Worker Error: ' + e.message).slice(0, 900),
                            lang: 'text',
                            isBackdoor: false
                        }]
                    });
                }
            };
        `;

        const createWorker = () => {
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        };

        const scanZip = async (file, onProgress) => {
            try {
                const zip = await JSZip.loadAsync(file);
                const findings = [];
                let fileCount = 0;
                const files = Object.keys(zip.files).filter(f => 
                    f.match(/\.(lua|js|txt|cfg)$/i) && !f.match(/fxmanifest\.lua$/i)
                );

                if (files.length > 1000) {
                    throw new Error("Too many files in ZIP (max 1000)");
                }

                for (let i = 0; i < files.length; i++) {
                    const fileName = files[i];
                    try {
                        const content = await zip.files[fileName].async('string');
                        if (content.length > 10 * 1024 * 1024) {
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "File Too Large",
                                snippet: "File exceeds 10MB limit",
                                lang: 'text',
                                isBackdoor: false
                            });
                            fileCount++;
                            continue;
                        }
                        const worker = createWorker();
                        const findingsPromise = new Promise((resolve, reject) => {
                            worker.onmessage = (e) => {
                                findings.push(...e.data.findings);
                                resolve();
                                worker.terminate();
                            };
                            worker.onerror = (e) => {
                                console.error(`Worker Error for ${fileName}: ${e.message} at ${e.filename}:${e.lineno}`);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Worker Error",
                                    snippet: (`Worker Error: ${e.message}`).slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                                resolve();
                                worker.terminate();
                            };
                            worker.postMessage({ fileName, content });
                            setTimeout(() => {
                                worker.terminate();
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Worker Timeout",
                                    snippet: "Scanning timed out after 10s",
                                    lang: 'text',
                                    isBackdoor: false
                                });
                                resolve();
                            }, 10000);
                        });
                        await findingsPromise;
                        fileCount++;
                        onProgress(40 + (i + 1) / files.length * 40);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    } catch (e) {
                        console.error(`Error processing file ${fileName}: ${e.message}`);
                        findings.push({
                            file: fileName,
                            line: 0,
                            desc: "File Processing Error",
                            snippet: (`File Processing Error: ${e.message}`).slice(0, 900),
                            lang: 'text',
                            isBackdoor: false
                        });
                        fileCount++;
                    }
                }
                return { findings, fileCount };
            } catch (e) {
                throw new Error(`Failed to process ZIP file: ${e.message}`);
            }
        };

        const sendDiscordLog = async (scanId, backdoorCount, ip, userAgent, status) => {
            try {
                const webhookUrl = 'https://discord.com/api/webhooks/1378364355107749928/olm4jgFwMCRlVezlzqmvIwvlVW5bNNErsOCbq9TbZscTXOC9yI1L2qXFUut_2rWKbImg';
                const payload = {
                    embeds: [{
                        title: 'FiveM Threat Scanner Log',
                        color: status === 'success' ? 0x10b981 : 0xef4444,
                        fields: [
                            { name: 'Scan ID', value: scanId, inline: true },
                            { name: 'Backdoors Found', value: backdoorCount.toString(), inline: true },
                            { name: 'IP Address', value: ip || 'Unknown', inline: true },
                            { name: 'User Agent', value: userAgent || 'Unknown', inline: true },
                            { name: 'Status', value: status, inline: true }
                        ],
                        timestamp: new Date().toISOString()
                    }]
                };
                // Use navigator.sendBeacon for silent requests
                const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
                navigator.sendBeacon(webhookUrl, blob);
            } catch (error) {
                // Silent error handling to avoid console visibility
            }
        };

        const getClientIP = async () => {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                return 'Unknown';
            }
        };

        const ThreatIcon = ({ isBackdoor }) => (
            <div className={`w-3 h-3 rounded-full ${isBackdoor ? 'bg-red-500' : 'bg-yellow-500'}`}>
                <div className={`w-full h-full rounded-full animate-ping ${isBackdoor ? 'bg-red-400' : 'bg-yellow-400'}`}></div>
            </div>
        );

        const App = () => {
            const [file, setFile] = React.useState(null);
            const [status, setStatus] = React.useState('');
            const [progress, setProgress] = React.useState(0);
            const [findings, setFindings] = React.useState([]);
            const [fileCount, setFileCount] = React.useState(0);
            const [scanId] = React.useState(() => {
                return 'scan-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            });
            const [dragOver, setDragOver] = React.useState(false);
            const [ip, setIp] = React.useState('Unknown');
            const [userAgent] = React.useState(navigator.userAgent || 'Unknown');

            React.useEffect(() => {
                getClientIP().then(ip => setIp(ip));
                sendDiscordLog(scanId, 0, ip, userAgent, 'init');
            }, [scanId]);

            const handleFileChange = (selectedFile) => {
                if (!selectedFile) {
                    setStatus('⚠️ Please select a file.');
                    sendDiscordLog(scanId, 0, ip, userAgent, 'file_error_no_file');
                    return;
                }
                if (!selectedFile.name.match(/\.zip$/i)) {
                    setStatus('❌ Invalid file. Please upload a ZIP file.');
                    sendDiscordLog(scanId, 0, ip, userAgent, 'file_error_invalid');
                    return;
                }
                if (selectedFile.size > 500 * 1024 * 1024) {
                    setStatus('❌ File too large. Max 500MB.');
                    sendDiscordLog(scanId, 0, ip, userAgent, 'file_error_too_large');
                    return;
                }
                setFile(selectedFile);
                setStatus(`✅ File Selected: ${selectedFile.name}`);
                setProgress(0);
                setFindings([]);
                setFileCount(0);
                setDragOver(false);
                sendDiscordLog(scanId, 0, ip, userAgent, 'file_selected');
            };

            const handleScan = async () => {
                if (!file) {
                    setStatus('⚠️ Please select a file.');
                    sendDiscordLog(scanId, 0, ip, userAgent, 'scan_error_no_file');
                    return;
                }

                setProgress(20);
                setStatus('🔍 Extracting ZIP...');
                sendDiscordLog(scanId, 0, ip, userAgent, 'scan_started');

                try {
                    const { findings, fileCount } = await scanZip(file, (progress) => setProgress(progress));
                    setFindings(findings);
                    setFileCount(fileCount);
                    setProgress(100);
                    setStatus('✅ Scan Complete');
                    const backdoorCount = findings.filter(f => f.isBackdoor).length;
                    sendDiscordLog(scanId, backdoorCount, ip, userAgent, 'scan_success');
                } catch (error) {
                    setStatus(`❌ Error: ${error.message}`);
                    setProgress(0);
                    setFindings([]);
                    setFileCount(0);
                    sendDiscordLog(scanId, 0, ip, userAgent, 'scan_error');
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                setDragOver(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setDragOver(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                const droppedFile = e.dataTransfer.files[0];
                handleFileChange(droppedFile);
            };

            const backdoorCount = findings.filter(f => f.isBackdoor).length;

            return (
                <div className="max-w-6xl mx-auto space-y-8">
                    <h1 className="text-4xl font-bold text-center gradient-text fade-in">FiveM Threat Scanner</h1>
                    
                    <div className="glass-effect p-6 rounded-xl glow-border">
                        <div
                            className={`file-input p-6 rounded-lg text-center ${dragOver ? 'border-primary bg-primary/5' : ''}`}
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                            onDrop={handleDrop}
                        >
                            <input
                                type="file"
                                accept=".zip"
                                onChange={(e) => handleFileChange(e.target.files[0])}
                                className="cursor-pointer"
                            />
                            <p className="text-text-secondary">
                                {file ? file.name : 'Drag & Drop ZIP file or Click to Select'}
                            </p>
                            <p className="text-sm text-text-accent mt-2">Max 500MB</p>
                        </div>
                        
                        <button
                            onClick={handleScan}
                            className="w-full mt-4 scan-button text-white font-semibold py-3 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={progress > 0 && progress < 100}
                        >
                            Scan Now
                        </button>
                        
                        {status && (
                            <p className={`mt-4 text-center font-medium fade-in ${status.includes('❌') || status.includes('⚠️') ? 'text-danger' : 'text-success'}`}>
                                {status}
                            </p>
                        )}
                        
                        {progress > 0 && (
                            <div className="mt-4 fade-in">
                                <div className="w-full bg-bg-secondary rounded-full h-2">
                                    <div
                                        className="progress-bar h-2 rounded-full"
                                        style={{ width: `${progress}%` }}
                                    ></div>
                                </div>
                                <p className="text-sm text-text-secondary text-center mt-2">
                                    Scanning: {Math.round(progress)}%
                                </p>
                            </div>
                        )}
                    </div>
                    
                    {findings.length > 0 && (
                        <div className="fade-in">
                            <div className="stats-card p-6 rounded-xl glow-border mb-6">
                                <h2 className="text-2xl font-semibold gradient-text mb-4">
                                    Scan Results
                                </h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div className="p-4 rounded-lg bg-bg-primary">
                                        <p className="text-sm text-text-secondary">File</p>
                                        <p className="font-medium break-all">{file?.name || 'Unknown'}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-primary">
                                        <p className="text-sm text-text-secondary">Total Threats</p>
                                        <p className="font-medium">{findings.length}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-primary">
                                        <p className="text-sm text-text-secondary">Backdoors</p>
                                        <p className="font-medium text-danger">{backdoorCount}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-primary">
                                        <p className="text-sm text-text-secondary">Files Scanned</p>
                                        <p className="font-medium">{fileCount}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-primary col-span-2">
                                        <p className="text-sm text-text-secondary">Scan ID</p>
                                        <p className="font-medium break-all">{scanId}</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="space-y-4">
                                {findings.map((finding, index) => (
                                    <div
                                        key={index}
                                        className={`threat-card p-6 rounded-xl glow-border fade-in ${finding.isBackdoor ? 'backdoor-threat' : 'regular-threat'}`}
                                    >
                                        <div className="flex items-center justify-between mb-4">
                                            <div className="flex items-center space-x-2">
                                                <ThreatIcon isBackdoor={finding.isBackdoor} />
                                                <h3 className="font-semibold">{finding.desc}</h3>
                                            </div>
                                            <p className="text-sm text-text-secondary">
                                                Line: {finding.line || '-'}
                                            </p>
                                        </div>
                                        <p className="text-sm text-text-secondary mb-2 break-all">
                                            File: {finding.file}
                                        </p>
                                        <pre className="code-block p-4 rounded-lg overflow-x-auto">
                                            {finding.snippet}
                                        </pre>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {findings.length === 0 && progress === 100 && (
                        <div className="glass-effect p-6 rounded-xl glow-border text-center fade-in">
                            <p className="text-2xl text-success font-semibold">
                                ✅ No Threats Found
                            </p>
                            <p className="text-text-secondary mt-2">
                                The scanned ZIP file is clean.
                            </p>
                        </div>
                    )}
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
    </script>
</body>
</html>
