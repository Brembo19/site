<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FiveM Threat Scanner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.24.7/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com/3.4.3"></script>
    <style>
        :root {
            --primary: #00d4ff;
            --primary-dark: #0099cc;
            --primary-light: #66e0ff;
            --secondary: #ff6b35;
            --accent: #ff3366;
            --danger: #ff1744;
            --success: #00e676;
            --warning: #ffab00;
            --bg-primary: #0a0a0f;
            --bg-secondary: #1a1a2e;
            --bg-accent: #16213e;
            --bg-card: #1e1e2e;
            --text-primary: #ffffff;
            --text-secondary: #b8bcc8;
            --text-accent: #8892b0;
            --border: #2a2a3a;
            --border-bright: #3a3a4a;
            --glow: rgba(0, 212, 255, 0.5);
            --glow-secondary: rgba(255, 107, 53, 0.3);
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--bg-secondary);
        }

        *::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        *::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        *::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 3px;
        }

        *::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--accent));
        }

        body {
            background: 
                radial-gradient(ellipse at top left, rgba(0, 212, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at top right, rgba(255, 107, 53, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom, rgba(255, 51, 102, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, var(--bg-primary) 0%, #0f0f1a 50%, var(--bg-primary) 100%);
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        .glass-effect {
            background: rgba(30, 30, 46, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .neo-border {
            position: relative;
            border: 1px solid var(--border);
        }

        .neo-border::before {
            content: '';
            position: absolute;
            inset: -1px;
            background: linear-gradient(45deg, 
                var(--primary), 
                var(--secondary), 
                var(--accent), 
                var(--primary)
            );
            background-size: 400% 400%;
            border-radius: inherit;
            z-index: -1;
            animation: borderGlow 4s ease-in-out infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .neo-border:hover::before {
            opacity: 1;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .scan-button {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 50%, var(--secondary) 100%);
            box-shadow: 
                0 4px 20px rgba(0, 212, 255, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .scan-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent
            );
            transition: left 0.6s ease;
        }

        .scan-button:hover::before {
            left: 100%;
        }

        .scan-button:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 40px rgba(0, 212, 255, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
        }

        .scan-button:active {
            transform: translateY(-1px);
        }

        .progress-bar {
            background: linear-gradient(90deg, 
                var(--primary), 
                var(--secondary), 
                var(--accent)
            );
            box-shadow: 
                0 0 20px var(--glow),
                0 0 40px var(--glow-secondary);
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: progressShimmer 2s infinite;
        }

        @keyframes progressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .threat-card {
            background: linear-gradient(135deg, 
                rgba(30, 30, 46, 0.8) 0%, 
                rgba(22, 33, 62, 0.6) 100%
            );
            border: 1px solid var(--border);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .threat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                var(--primary), 
                var(--secondary), 
                var(--accent)
            );
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .threat-card:hover::before {
            transform: scaleX(1);
        }

        .threat-card:hover {
            border-color: var(--primary);
            box-shadow: 
                0 12px 30px rgba(0, 212, 255, 0.2),
                0 0 20px rgba(255, 107, 53, 0.1);
            transform: translateY(-4px);
        }

        .backdoor-threat {
            border-left: 4px solid var(--danger);
            background: linear-gradient(135deg, 
                rgba(255, 23, 68, 0.15) 0%, 
                rgba(30, 30, 46, 0.8) 100%
            );
            box-shadow: 0 0 20px rgba(255, 23, 68, 0.1);
        }

        .regular-threat {
            border-left: 4px solid var(--warning);
            background: linear-gradient(135deg, 
                rgba(255, 171, 0, 0.15) 0%, 
                rgba(30, 30, 46, 0.8) 100%
            );
            box-shadow: 0 0 20px rgba(255, 171, 0, 0.1);
        }

        .file-input {
            background: linear-gradient(135deg, 
                var(--bg-secondary) 0%, 
                var(--bg-card) 100%
            );
            border: 2px dashed var(--border);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .file-input::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg,
                rgba(0, 212, 255, 0.1),
                rgba(255, 107, 53, 0.1)
            );
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .file-input:hover::before {
            opacity: 1;
        }

        .file-input:hover {
            border-color: var(--primary);
            border-style: solid;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        .file-input input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 10;
        }

        .pulse-animation {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .code-block {
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(135deg, 
                var(--bg-primary) 0%, 
                rgba(30, 30, 46, 0.8) 100%
            );
            border: 1px solid var(--border);
            font-size: 0.875rem;
            line-height: 1.6;
            position: relative;
        }

        .code-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, 
                var(--primary), 
                var(--secondary)
            );
        }

        .stats-card {
            background: linear-gradient(135deg, 
                var(--bg-secondary) 0%, 
                var(--bg-accent) 50%,
                var(--bg-card) 100%
            );
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .stats-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg,
                transparent,
                rgba(0, 212, 255, 0.05),
                transparent
            );
            animation: statsShimmer 8s linear infinite;
        }

        @keyframes statsShimmer {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .floating-orb {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
        }

        .orb-1 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, 
                rgba(0, 212, 255, 0.15) 0%, 
                transparent 70%
            );
            top: -10%;
            left: -10%;
            animation: float1 12s ease-in-out infinite;
        }

        .orb-2 {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, 
                rgba(255, 107, 53, 0.12) 0%, 
                transparent 70%
            );
            top: 20%;
            right: -5%;
            animation: float2 10s ease-in-out infinite reverse;
        }

        .orb-3 {
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, 
                rgba(255, 51, 102, 0.1) 0%, 
                transparent 70%
            );
            bottom: -10%;
            right: 30%;
            animation: float3 14s ease-in-out infinite;
        }

        @keyframes float1 {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(30px, -40px) rotate(120deg); }
            66% { transform: translate(-20px, 20px) rotate(240deg); }
        }

        @keyframes float2 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-40px, 30px) scale(1.1); }
        }

        @keyframes float3 {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-30px) rotate(180deg); }
        }

        .gradient-text {
            background: linear-gradient(135deg, 
                var(--primary-light) 0%, 
                var(--secondary) 50%,
                var(--accent) 100%
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
        }

        .hero-title {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 1rem;
        }

        .cyber-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.3;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        .scan-animation {
            position: relative;
            overflow: hidden;
        }

        .scan-animation::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent,
                rgba(0, 212, 255, 0.6),
                transparent
            );
            animation: scanning 2s ease-in-out infinite;
        }

        @keyframes scanning {
            0% { left: -100%; }
            100% { left: 100%; }
        }
    </style>
</head>
<body>
    <div class="cyber-grid"></div>
    <div class="floating-orb orb-1"></div>
    <div class="floating-orb orb-2"></div>
    <div class="floating-orb orb-3"></div>
    
    <div id="root" class="min-h-screen py-8 px-4"></div>
    
    <script type="text/babel" data-presets="react">
        const THREAT_PATTERNS = [
            { pattern: /backdoor/i, desc: "Backdoor Reference", severity: "medium" },
            { pattern: /PerformHttpRequest/i, desc: "Backdoor: FiveM HTTP Request", severity: "high" },
            { pattern: /http\.request/i, desc: "Backdoor: Lua HTTP Request", severity: "high" },
            { pattern: /loadstring/i, desc: "Backdoor: Dynamic Lua Code", severity: "high" },
            { pattern: /os\.execute/i, desc: "System Command Execution", severity: "critical" },
            { pattern: /exec/i, desc: "Code Execution", severity: "high" },
            { pattern: /socket/i, desc: "Network Socket", severity: "medium" },
            { pattern: /connect/i, desc: "Connection Attempt", severity: "medium" },
            { pattern: /eval/i, desc: "JS Eval", severity: "high" },
            { pattern: /Function\.constructor/i, desc: "Dynamic JS Code", severity: "high" },
            { pattern: /XMLHttpRequest/i, desc: "JS HTTP Request", severity: "medium" },
            { pattern: /fetch/i, desc: "JS Fetch API", severity: "medium" },
            { pattern: /crypto/i, desc: "Crypto Library", severity: "medium" },
            { pattern: /wallet/i, desc: "Crypto Wallet", severity: "medium" },
            { pattern: /miner/i, desc: "Crypto Miner", severity: "high" },
            { pattern: /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/, desc: "Bitcoin Address", severity: "medium" },
            { pattern: /0x[a-fA-F0-9]{40}/, desc: "Ethereum Address", severity: "medium" },
            { pattern: /mining/i, desc: "Mining Keyword", severity: "medium" },
            { pattern: /hashrate/i, desc: "Mining Metric", severity: "medium" },
            { pattern: /blockchain/i, desc: "Blockchain Term", severity: "low" },
            { pattern: /WebAssembly/i, desc: "WASM Mining", severity: "high" },
            { pattern: /crypto\.subtle/i, desc: "Web Crypto API", severity: "medium" },
            { pattern: /\\x[0-9a-fA-F]{2}(\\x[0-9a-fA-F]{2}){3,}/, desc: "Obfuscated Hex Payload", severity: "high" },
            { pattern: /_G\s*\[[^\]]+\]\s*\(/i, desc: "Backdoor: Dynamic Global Function Call", severity: "high" },
            { pattern: /=\s*{[^}]*\\x[0-9a-fA-F]{2}/, desc: "Obfuscated Array with Hex Values", severity: "high" },
            { pattern: /\[\s*_G\s*\[\s*["']?[a-zA-Z0-9_]{4,}["']?\s*\]\s*\]/i, desc: "Backdoor: Nested _G Lookup", severity: "high" },
            { pattern: /webhook/i, desc: "Webhook Reference", severity: "medium" },
            { pattern: /Buffer\.from\s*\(\s*['"][A-Za-z0-9+/=]+['"]\s*,\s*['"]base64['"]\s*\)/i, desc: "Obfuscated JS Buffer Payload", severity: "high" },
            { pattern: /load\s*\(\s*[^)]+\)/i, desc: "Backdoor: Lua Load Function", severity: "high" },
            { pattern: /RunCode\s*\(/i, desc: "Backdoor: FiveM RunCode Execution", severity: "critical" },
            { pattern: /http\.Get\s*\(/i, desc: "Backdoor: FiveM HTTP Get Request", severity: "high" },
            { pattern: /TriggerServerEvent\s*\(\s*['"][^'"]+['"]\s*,/i, desc: "Backdoor: Suspicious Server Event Trigger", severity: "high" },
            { pattern: /ExecuteCommand\s*\(\s*['"][^'"]+['"]\s*\)/i, desc: "Backdoor: Command Execution", severity: "critical" },
            { pattern: /AddEventHandler\s*\(\s*['"][^'"]+['"]\s*,/i, desc: "Backdoor: Suspicious Event Handler", severity: "high" },
            { pattern: /Citizen\.CreateThread\s*\(/i, desc: "Backdoor: Citizen Thread Creation", severity: "high" },
            { pattern: /string\.char\s*\(\s*(0x[0-9a-fA-F]+|[0-9]+)\s*[,)]/i, desc: "Backdoor: Obfuscated String via string.char", severity: "high" },
            { pattern: /[\w]+\s*\.\s*concat\s*\(\s*[\w]+\s*\)/i, desc: "Backdoor: String Concatenation Obfuscation", severity: "high" },
            { pattern: /[\w$]+\s*=\s*string\.reverse\s*\(['"]([^'"]+)['"]\)/i, desc: "Obfuscated String Reverse", severity: "high" },
            { pattern: /[\w$]+\s*=\s*string\.gsub\s*\(\s*['"]([^'"]+)['"]/i, desc: "Obfuscated String Substitution", severity: "high" },
            { pattern: /[\w$]+\s*=\s*function\s*\([^)]*\)\s*return\s*['"]([^'"]+)['"]/i, desc: "Obfuscated Function Return", severity: "high" }
        ];

        const workerScript = `
            const THREAT_PATTERNS = ${JSON.stringify(THREAT_PATTERNS)};

            const xorDecode = (text, key = "secret") => {
                try {
                    key = key.slice(0, Math.min(text.length, key.length)) || "secret";
                    let result = '';
                    for (let i = 0; i < text.length; i++) {
                        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return result.split('').every(c => (c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126) || ['\\n', '\\r', '\\t'].includes(c)) ? result : null;
                } catch (e) {
                    return { error: 'XOR Decode Error: ' + e.message };
                }
            };

            const base64Decode = (text) => {
                try {
                    if (text.length % 4 !== 0) text += '='.repeat(4 - text.length % 4);
                    const decoded = atob(text);
                    return decoded.split('').every(c => (c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126) || ['\\n', '\\r', '\\t'].includes(c)) ? decoded : null;
                } catch (e) {
                    return { error: 'Base64 Decode Error: ' + e.message };
                }
            };

            const hexDecode = (text) => {
                try {
                    const hex = text.replace(/\\x/g, '');
                    if (hex.length % 2 !== 0) return null;
                    let result = '';
                    for (let i = 0; i < hex.length; i += 2) {
                        result += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
                    }
                    return result.split('').every(c => (c.charCodeAt(0) >= 32 && c.charCodeAt(0) <= 126) || ['\\n', '\\r', '\\t'].includes(c)) ? result : null;
                } catch (e) {
                    return { error: 'Hex Decode Error: ' + e.message };
                }
            };

            const rot13Decode = (text) => {
                try {
                    return text.replace(/[a-zA-Z]/g, c => String.fromCharCode((c.charCodeAt(0) - (c <= 'M' ? 65 : 97) + 13) % 26 + (c <= 'M' ? 65 : 97)));
                } catch (e) {
                    return { error: 'ROT13 Decode Error: ' + e.message };
                }
            };

            const scanFile = (fileName, content) => {
                const findings = [];
                const seen = new Set();
                const lines = content.split('\\n');
                const lang = fileName.match(/\\.js$/i) ? 'js' : fileName.match(/\\.lua$/i) ? 'lua' : 'text';
                const MAX_MATCHES = 100;

                // Direct pattern matching
                for (const { pattern, desc, severity } of THREAT_PATTERNS) {
                    try {
                        const regex = new RegExp(pattern.source, pattern.flags);
                        let match;
                        let matchCount = 0;
                        while ((match = regex.exec(content)) && matchCount < MAX_MATCHES) {
                            const lineNum = content.slice(0, match.index).split('\\n').length;
                            const key = fileName + ':' + lineNum + ':' + desc;
                            if (!seen.has(key)) {
                                seen.add(key);
                                const contextLines = desc.includes("Backdoor") ? 7 : 3;
                                const startLine = Math.max(0, lineNum - contextLines);
                                const endLine = Math.min(lines.length, lineNum + contextLines);
                                let snippet = lines.slice(startLine, endLine).join('\\n').slice(0, 900);
                                if (snippet.length >= 900) snippet += '...';
                                findings.push({
                                    file: fileName,
                                    line: lineNum,
                                    desc,
                                    severity,
                                    snippet,
                                    lang,
                                    isBackdoor: desc.includes("Backdoor") || severity === "critical"
                                });
                            }
                            matchCount++;
                        }
                    } catch (e) {
                        const key = fileName + ':0:Regex Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "Regex Error",
                                severity: "low",
                                snippet: ('Regex Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                // Decode and scan Base64
                const base64Matches = content.match(/[A-Za-z0-9+/=]{20,}/g) || [];
                for (const match of base64Matches) {
                    try {
                        const decoded = base64Decode(match);
                        if (decoded && !decoded.error) {
                            let matchCount = 0;
                            for (const { pattern, desc, severity } of THREAT_PATTERNS) {
                                if (matchCount >= MAX_MATCHES) break;
                                if (pattern.test(decoded)) {
                                    const key = fileName + ':0:' + desc + ' (Base64)';
                                    if (!seen.has(key)) {
                                        seen.add(key);
                                        const snippet = decoded.slice(0, 900) + (decoded.length > 900 ? '...' : '');
                                        findings.push({
                                            file: fileName,
                                            line: 0,
                                            desc: desc + ' (Base64)',
                                            severity,
                                            snippet,
                                            lang,
                                            isBackdoor: desc.includes("Backdoor") || severity === "critical"
                                        });
                                    }
                                    matchCount++;
                                }
                            }
                        } else if (decoded && decoded.error) {
                            const key = fileName + ':0:Base64 Decode Error';
                            if (!seen.has(key)) {
                                seen.add(key);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Base64 Decode Error",
                                    severity: "low",
                                    snippet: decoded.error.slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                            }
                        }
                    } catch (e) {
                        const key = fileName + ':0:Base64 Decode Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "Base64 Decode Error",
                                severity: "low",
                                snippet: ('Base64 Decode Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                // Decode and scan XOR
                const keys = ["secret", "key", "xor", "password", "fivem", "lua", "backdoor", "crypto", "mine", "server", "admin", "execute"];
                for (const xorKey of keys) {
                    try {
                        const decoded = xorDecode(content, xorKey);
                        if (decoded && !decoded.error) {
                            let matchCount = 0;
                            for (const { pattern, desc, severity } of THREAT_PATTERNS) {
                                if (matchCount >= MAX_MATCHES) break;
                                if (pattern.test(decoded)) {
                                    const uniqueKey = fileName + ':0:' + desc + ' (XOR: ' + xorKey + ')';
                                    if (!seen.has(uniqueKey)) {
                                        seen.add(uniqueKey);
                                        const snippet = decoded.slice(0, 900) + (decoded.length > 900 ? '...' : '');
                                        findings.push({
                                            file: fileName,
                                            line: 0,
                                            desc: desc + ' (XOR: ' + xorKey + ')',
                                            severity,
                                            snippet,
                                            lang,
                                            isBackdoor: desc.includes("Backdoor") || severity === "critical"
                                        });
                                    }
                                    matchCount++;
                                }
                            }
                        } else if (decoded && decoded.error) {
                            const key = fileName + ':0:XOR Decode Error';
                            if (!seen.has(key)) {
                                seen.add(key);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "XOR Decode Error",
                                    severity: "low",
                                    snippet: decoded.error.slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                            }
                        }
                    } catch (e) {
                        const key = fileName + ':0:XOR Decode Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "XOR Decode Error",
                                severity: "low",
                                snippet: ('XOR Decode Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                // Decode and scan Hex
                const hexMatches = content.match(/\\x[0-9a-fA-F]{2}(?:\\x[0-9a-fA-F]{2})+/g) || [];
                for (const match of hexMatches) {
                    try {
                        const decoded = hexDecode(match);
                        if (decoded && !decoded.error) {
                            let matchCount = 0;
                            for (const { pattern, desc, severity } of THREAT_PATTERNS) {
                                if (matchCount >= MAX_MATCHES) break;
                                if (pattern.test(decoded)) {
                                    const key = fileName + ':0:' + desc + ' (Hex)';
                                    if (!seen.has(key)) {
                                        seen.add(key);
                                        const snippet = decoded.slice(0, 900) + (decoded.length > 900 ? '...' : '');
                                        findings.push({
                                            file: fileName,
                                            line: 0,
                                            desc: desc + ' (Hex)',
                                            severity,
                                            snippet,
                                            lang,
                                            isBackdoor: desc.includes("Backdoor") || severity === "critical"
                                        });
                                    }
                                    matchCount++;
                                }
                            }
                        } else if (decoded && decoded.error) {
                            const key = fileName + ':0:Hex Decode Error';
                            if (!seen.has(key)) {
                                seen.add(key);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Hex Decode Error",
                                    severity: "low",
                                    snippet: decoded.error.slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                            }
                        }
                    } catch (e) {
                        const key = fileName + ':0:Hex Decode Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "Hex Decode Error",
                                severity: "low",
                                snippet: ('Hex Decode Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                // Decode and scan ROT13
                const rot13Matches = content.match(/[a-zA-Z]{10,}/g) || [];
                for (const match of rot13Matches) {
                    try {
                        const decoded = rot13Decode(match);
                        if (decoded && !decoded.error) {
                            let matchCount = 0;
                            for (const { pattern, desc, severity } of THREAT_PATTERNS) {
                                if (matchCount >= MAX_MATCHES) break;
                                if (pattern.test(decoded)) {
                                    const key = fileName + ':0:' + desc + ' (ROT13)';
                                    if (!seen.has(key)) {
                                        seen.add(key);
                                        const snippet = decoded.slice(0, 900) + (decoded.length > 900 ? '...' : '');
                                        findings.push({
                                            file: fileName,
                                            line: 0,
                                            desc: desc + ' (ROT13)',
                                            severity,
                                            snippet,
                                            lang,
                                            isBackdoor: desc.includes("Backdoor") || severity === "critical"
                                        });
                                    }
                                    matchCount++;
                                }
                            }
                        } else if (decoded && decoded.error) {
                            const key = fileName + ':0:ROT13 Decode Error';
                            if (!seen.has(key)) {
                                seen.add(key);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "ROT13 Decode Error",
                                    severity: "low",
                                    snippet: decoded.error.slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                            }
                        }
                    } catch (e) {
                        const key = fileName + ':0:ROT13 Decode Error';
                        if (!seen.has(key)) {
                            seen.add(key);
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "ROT13 Decode Error",
                                severity: "low",
                                snippet: ('ROT13 Decode Error: ' + e.message).slice(0, 900),
                                lang: 'text',
                                isBackdoor: false
                            });
                        }
                    }
                }

                return findings;
            };

            self.onmessage = async (e) => {
                try {
                    const { fileName, content } = e.data;
                    if (content.length > 10 * 1024 * 1024) {
                        self.postMessage({
                            fileName,
                            findings: [{
                                file: fileName,
                                line: 0,
                                desc: "File Too Large",
                                severity: "low",
                                snippet: "File exceeds 10MB limit",
                                lang: 'text',
                                isBackdoor: false
                            }]
                        });
                        return;
                    }
                    const findings = scanFile(fileName, content);
                    self.postMessage({ fileName, findings });
                } catch (e) {
                    self.postMessage({
                        fileName: e.data?.fileName || 'Unknown',
                        findings: [{
                            file: e.data?.fileName || 'Unknown',
                            line: 0,
                            desc: "Worker Error",
                            severity: "low",
                            snippet: ('Worker Error: ' + e.message).slice(0, 900),
                            lang: 'text',
                            isBackdoor: false
                        }]
                    });
                }
            };
        `;

        const createWorker = () => {
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        };

        const scanZip = async (file, onProgress) => {
            try {
                const zip = await JSZip.loadAsync(file);
                const findings = [];
                let fileCount = 0;
                const files = Object.keys(zip.files).filter(f => 
                    f.match(/\.(lua|js|txt|cfg)$/i) && !f.match(/fxmanifest\.lua$/i)
                );

                if (files.length > 1000) {
                    throw new Error("Too many files in ZIP (max 1000)");
                }

                for (let i = 0; i < files.length; i++) {
                    const fileName = files[i];
                    try {
                        const content = await zip.files[fileName].async('string');
                        if (content.length > 10 * 1024 * 1024) {
                            findings.push({
                                file: fileName,
                                line: 0,
                                desc: "File Too Large",
                                severity: "low",
                                snippet: "File exceeds 10MB limit",
                                lang: 'text',
                                isBackdoor: false
                            });
                            fileCount++;
                            continue;
                        }
                        const worker = createWorker();
                        const findingsPromise = new Promise((resolve, reject) => {
                            worker.onmessage = (e) => {
                                findings.push(...e.data.findings);
                                resolve();
                                worker.terminate();
                            };
                            worker.onerror = (e) => {
                                console.error(`Worker Error for ${fileName}: ${e.message} at ${e.filename}:${e.lineno}`);
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Worker Error",
                                    severity: "low",
                                    snippet: (`Worker Error: ${e.message}`).slice(0, 900),
                                    lang: 'text',
                                    isBackdoor: false
                                });
                                resolve();
                                worker.terminate();
                            };
                            worker.postMessage({ fileName, content });
                            setTimeout(() => {
                                worker.terminate();
                                findings.push({
                                    file: fileName,
                                    line: 0,
                                    desc: "Worker Timeout",
                                    severity: "low",
                                    snippet: "Scanning timed out after 10s",
                                    lang: 'text',
                                    isBackdoor: false
                                });
                                resolve();
                            }, 10000);
                        });
                        await findingsPromise;
                        fileCount++;
                        onProgress(40 + (i + 1) / files.length * 40);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    } catch (e) {
                        console.error(`Error processing file ${fileName}: ${e.message}`);
                        findings.push({
                            file: fileName,
                            line: 0,
                            desc: "File Processing Error",
                            severity: "low",
                            snippet: (`File Processing Error: ${e.message}`).slice(0, 900),
                            lang: 'text',
                            isBackdoor: false
                        });
                        fileCount++;
                    }
                }
                return { findings, fileCount };
            } catch (e) {
                throw new Error(`Failed to process ZIP file: ${e.message}`);
            }
        };

        const ThreatIcon = ({ isBackdoor, severity }) => {
            const color = severity === "critical" ? 'bg-red-600' : 
                        severity === "high" ? 'bg-red-500' : 
                        severity === "medium" ? 'bg-yellow-500' : 'bg-blue-500';
            const pingColor = severity === "critical" ? 'bg-red-500' : 
                            severity === "high" ? 'bg-red-400' : 
                            severity === "medium" ? 'bg-yellow-400' : 'bg-blue-400';
            return (
                <div className={`w-3 h-3 rounded-full ${color}`}>
                    <div className={`w-full h-full rounded-full animate-ping ${pingColor}`}></div>
                </div>
            );
        };

        const App = () => {
            const [file, setFile] = React.useState(null);
            const [status, setStatus] = React.useState('');
            const [progress, setProgress] = React.useState(0);
            const [findings, setFindings] = React.useState([]);
            const [fileCount, setFileCount] = React.useState(0);
            const [scanId] = React.useState(() => {
                return 'scan-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            });
            const [dragOver, setDragOver] = React.useState(false);

            const handleFileChange = (selectedFile) => {
                if (!selectedFile) {
                    setStatus('⚠️ Please select a file.');
                    return;
                }
                if (!selectedFile.name.match(/\.zip$/i)) {
                    setStatus('❌ Invalid file. Please upload a ZIP file.');
                    return;
                }
                if (selectedFile.size > 500 * 1024 * 1024) {
                    setStatus('❌ File too large. Max 500MB.');
                    return;
                }
                setFile(selectedFile);
                setStatus(`✅ File Selected: ${selectedFile.name}`);
                setProgress(0);
                setFindings([]);
                setFileCount(0);
                setDragOver(false);
            };

            const handleScan = async () => {
                if (!file) {
                    setStatus('⚠️ Please select a file.');
                    return;
                }

                setProgress(20);
                setStatus('🔍 Extracting ZIP...');

                try {
                    const { findings, fileCount } = await scanZip(file, (progress) => setProgress(progress));
                    setFindings(findings);
                    setFileCount(fileCount);
                    setProgress(100);
                    setStatus('✅ Scan Complete');
                } catch (error) {
                    setStatus(`❌ Error: ${error.message}`);
                    setProgress(0);
                    setFindings([]);
                    setFileCount(0);
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                setDragOver(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setDragOver(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                const droppedFile = e.dataTransfer.files[0];
                handleFileChange(droppedFile);
            };

            const backdoorCount = findings.filter(f => f.isBackdoor).length;
            const stats = {
                scanned: fileCount,
                threats: findings.length,
                backdoors: backdoorCount,
                clean: fileCount - findings.length
            };

            return (
                <div className="max-w-6xl mx-auto">
                    <div className="text-center mb-12">
                        <h1 className="hero-title gradient-text fade-in">FiveM Threat Scanner</h1>
                        <p className="text-xl text-text-secondary max-w-2xl mx-auto">
                            Advanced malware detection and security analysis for FiveM resources
                        </p>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
                        <div className="lg:col-span-2">
                            <div className="glass-effect neo-border rounded-2xl p-8">
                                <h2 className="text-2xl font-bold mb-6 flex items-center">
                                    <span className="w-2 h-2 bg-primary rounded-full mr-3 pulse-animation"></span>
                                    Upload Resource
                                </h2>
                                
                                <div
                                    className={`file-input rounded-xl p-12 text-center mb-6 relative ${dragOver ? 'border-primary border-solid' : ''}`}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                >
                                    <input
                                        type="file"
                                        accept=".zip"
                                        onChange={(e) => handleFileChange(e.target.files[0])}
                                        className="cursor-pointer"
                                    />
                                    <div className="relative z-20">
                                        <svg className="w-16 h-16 mx-auto mb-4 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                        </svg>
                                        <h3 className="text-xl font-semibold mb-2">
                                            {file ? file.name : 'Drop your FiveM resource here'}
                                        </h3>
                                        <p className="text-text-secondary">
                                            {file ? 
                                                `Ready to scan • ${(file.size / 1024 / 1024).toFixed(2)} MB` : 
                                                'Supports .zip files'
                                            }
                                        </p>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={handleScan}
                                    className="scan-button w-full py-4 px-8 rounded-xl text-white disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled={progress > 0 && progress < 100}
                                >
                                    {progress > 0 && progress < 100 ? (
                                        <span className="flex items-center justify-center">
                                            <div className="scan-animation w-6 h-6 mr-3">
                                                <svg className="animate-spin" fill="none" viewBox="0 0 24 24">
                                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                            </div>
                                            Scanning... {Math.round(progress)}%
                                        </span>
                                    ) : (
                                        'Start Deep Scan'
                                    )}
                                </button>
                                
                                {status && (
                                    <p className={`mt-6 text-center font-medium fade-in ${status.includes('❌') || status.includes('⚠️') ? 'text-danger' : 'text-success'}`}>
                                        {status}
                                    </p>
                                )}
                                
                                {progress > 0 && (
                                    <div className="mt-6 fade-in">
                                        <div className="bg-bg-secondary rounded-full h-3 overflow-hidden">
                                            <div
                                                className="progress-bar h-full rounded-full"
                                                style={{ width: `${progress}%` }}
                                            ></div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                    
                    {findings.length > 0 && (
                        <div className="fade-in">
                            <div className="stats-card neo-border rounded-2xl p-8 mb-8">
                                <h2 className="text-2xl font-bold gradient-text mb-6">
                                    Scan Results
                                </h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div className="p-4 rounded-lg bg-bg-card">
                                        <p className="text-sm text-text-secondary">File</p>
                                        <p className="font-medium break-all">{file?.name || 'Unknown'}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-card">
                                        <p className="text-sm text-text-secondary">Total Threats</p>
                                        <p className="font-medium">{stats.threats}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-card">
                                        <p className="text-sm text-text-secondary">Backdoors</p>
                                        <p className="font-medium text-danger">{stats.backdoors}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-card">
                                        <p className="text-sm text-text-secondary">Files Scanned</p>
                                        <p className="font-medium">{stats.scanned}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-card">
                                        <p className="text-sm text-text-secondary">Clean Files</p>
                                        <p className="font-medium text-success">{stats.clean}</p>
                                    </div>
                                    <div className="p-4 rounded-lg bg-bg-card">
                                        <p className="text-sm text-text-secondary">Scan ID</p>
                                        <p className="font-medium break-all">{scanId}</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="space-y-4">
                                {findings.map((finding, index) => (
                                    <div
                                        key={index}
                                        className={`threat-card neo-border rounded-xl p-6 fade-in ${finding.isBackdoor ? 'backdoor-threat' : 'regular-threat'}`}
                                    >
                                        <div className="flex items-center justify-between mb-4">
                                            <div className="flex items-center space-x-2">
                                                <ThreatIcon isBackdoor={finding.isBackdoor} severity={finding.severity} />
                                                <h3 className="font-semibold">{finding.desc}</h3>
                                            </div>
                                            <p className="text-sm text-text-secondary">
                                                Line: {finding.line || '-'}
                                            </p>
                                        </div>
                                        <p className="text-sm text-text-secondary mb-2 break-all">
                                            File: {finding.file}
                                        </p>
                                        <pre className="code-block p-4 rounded-lg overflow-x-auto">
                                            {finding.snippet}
                                        </pre>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {findings.length === 0 && progress === 100 && (
                        <div className="glass-effect neo-border rounded-2xl p-8 text-center fade-in">
                            <p className="text-2xl text-success font-semibold">
                                ✅ No Threats Found
                            </p>
                            <p className="text-text-secondary mt-2">
                                The scanned ZIP file is clean.
                            </p>
                        </div>
                    )}
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
    </script>
</body>
</html>
